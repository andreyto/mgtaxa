<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mgtaxa: MGT::TaxaTree::TaxaNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>MGT</b>      </li>
      <li><b>TaxaTree</b>      </li>
      <li><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html">TaxaNode</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>MGT::TaxaTree::TaxaNode Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGT::TaxaTree::TaxaNode" -->
<p><a href="classMGT_1_1TaxaTree_1_1TaxaNode-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ad1c29d186f2a22d4573859e2cf2c991e">setDebugOnUpdate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a717adeacf7429d92f27bff32192908dd">unsetDebugOnUpdate</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a3b9cc38ec6c4966738443ee69b0e611d">__init__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a0fd2e60fa74f1293c8f37c0a57f398a1">__getstate__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a403ecd06e243563770c20f9bac832620">setParent</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ac114afcdcdf3bad2498a68c7c0234ac3">removeChild</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#afdd9d57946e0e08e0295199d33b43b12">lineage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ab3411b9ab2d887f28283fc2f1b1649ca">lineageWhile</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a2d6b844eaa8e9144371b217422029010">findLeftRankInLineage</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a33de4850fa68ac2757abb18eea84cc05">visitDepthTop</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a8799aea055e40ba8fdcb44fa36dff694">iterDepthTop</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ab09fc1ddd5aeb22e6796888079b63c55">iterDepthTwice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ab70ca116c742c9a2cff520c7b652b6cc">iterFillUp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ae13e9b0d297505fbed737a8d39c90f58">visitDepthBottom</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a85335c13c07a15f9cf18fe7b6d6533c8">visitDepthTwice</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a75e81088485134696e4a9896a88ca816">getDepth</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a8ca6419207107613bc000a9f8a74acec">setDepth</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a2c3a76551fdf1a2d9839227d4fed8d04">setIndex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a82fdc39394420ab00779563c91a95b5f">makePropArrayZeros</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a6485971ef870f36881ecb3a31c29b3dd">setPropArrayFromAttrib</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ae850d42b40116d7a0c70a0b62b414bc2">setPropArrayFromFunc</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a54217795cb97f755da4b347bf1918089">setTotal</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ae64d698b01b559f677b713ab52ce1dd4">setReduction</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a7c632d9896f0fd5cd596e2bd6e0a87e1">setMaxSubtreeRank</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#addaf7e7b67013a5450f2b9f2544efc80">setAttribute</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#aa982357b4bd2d7715598054d759e6df8">isSubnode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a6d3895e33537f43dc44b55b8edf389bd">isUnder</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#af1183314476b765ebdae34a2a9564daa">whichSupernode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ad4eda6b3eeec312541beb372e02d6c86">lcsNode</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a4d86f42266a6e38d20ce1ca6c1d9b851">lcsNodeMany</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a154bcb893a4deba83c12f16175be1362">setIsUnderUnclass</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment">Node of a taxonomy tree.</pre></div> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3b9cc38ec6c4966738443ee69b0e611d"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::__init__" ref="a3b9cc38ec6c4966738443ee69b0e611d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Ctor.
All parameters are optional keyword arguments, which will be assigned w/o any further processing.
Currently valid arguments:
@param id Node unique id
@param rank Rank of this node. Describes vertical division of the tree such as with "species,genus,order,class,..."
@param divid NCBI division id. Groups nodes, typically horizontally (bacterial, phage,...)
@param name official name of the node
@param names dict for other names "name type" -&gt; "name"

This constructor can be used w/o any arguments to create an empty object, which is then initialized by a
data loading procedure and linked into the tree with self.setParent(). Alternatively, it can be initialized
by the caling code by supplying keyword arguments, and then linked by self.setParent()</pre></div> 
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0fd2e60fa74f1293c8f37c0a57f398a1"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::__getstate__" ref="a0fd2e60fa74f1293c8f37c0a57f398a1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::__getstate__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Pickling support - exclude node cross references to improve memory and performance 100x.
The TaxaTree constructor can restore the internal tree structure from remaining data.
The TaxaTreeIO.NodeStoragePickle relies on this.</pre></div> 
</div>
</div>
<a class="anchor" id="a2d6b844eaa8e9144371b217422029010"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::findLeftRankInLineage" ref="a2d6b844eaa8e9144371b217422029010" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::findLeftRankInLineage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>topNode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return a node corresponding to the left-most element from 'ranks' found in the lineage</pre></div> 
</div>
</div>
<a class="anchor" id="a75e81088485134696e4a9896a88ca816"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::getDepth" ref="a75e81088485134696e4a9896a88ca816" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::getDepth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return distance to the top of the tree.
Depth must be precalculated for each node by a call to TaxaTree.setDepth().</pre></div> 
</div>
</div>
<a class="anchor" id="aa982357b4bd2d7715598054d759e6df8"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::isSubnode" ref="aa982357b4bd2d7715598054d759e6df8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::isSubnode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return true if this node is a descendant of the other node.
Uses pre-computed nested sets indexes, which must be up-to-date.
@note A node is not considered a subnode of itself - see isUnder() for this.</pre></div> 
</div>
</div>
<a class="anchor" id="a6d3895e33537f43dc44b55b8edf389bd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::isUnder" ref="a6d3895e33537f43dc44b55b8edf389bd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::isUnder </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>withSelf</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return true if this node is a descendant of the other node or the other node itself.
Uses pre-computed nested sets indexes, which must be up-to-date.</pre></div> 
</div>
</div>
<a class="anchor" id="a8799aea055e40ba8fdcb44fa36dff694"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterDepthTop" ref="a8799aea055e40ba8fdcb44fa36dff694" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::iterDepthTop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return depth-first top-to-bottom iterator.</pre></div> 
</div>
</div>
<a class="anchor" id="ab09fc1ddd5aeb22e6796888079b63c55"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterDepthTwice" ref="ab09fc1ddd5aeb22e6796888079b63c55" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::iterDepthTwice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return depth-first on-entry+on-exit iterator (modified preorder).
Dereferencing the iterator yields (node,visit) tuple, where visit is either 1 or 2 according to the time that we visit this node.
See setNestedSetsIndex() method for application example.</pre></div> 
</div>
</div>
<a class="anchor" id="ab70ca116c742c9a2cff520c7b652b6cc"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterFillUp" ref="ab70ca116c742c9a2cff520c7b652b6cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::iterFillUp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>topNode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>topFirst</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Iterate as though we were pouring water into this node until it fills a given super-tree above it.
@param topNode - "fill up" up to this super-node (inclusive), None means up to root node.
@param topFirst - if True, the top node of each super-tree will be iterated before its sub-nodes, otherwise - after ("self" is always iterated first).</pre></div> 
</div>
</div>
<a class="anchor" id="ad4eda6b3eeec312541beb372e02d6c86"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lcsNode" ref="ad4eda6b3eeec312541beb372e02d6c86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::lcsNode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return the Lowest Common SuperNode of self and other</pre></div> 
</div>
</div>
<a class="anchor" id="a4d86f42266a6e38d20ce1ca6c1d9b851"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lcsNodeMany" ref="a4d86f42266a6e38d20ce1ca6c1d9b851" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::lcsNodeMany </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return the Lowest Common SuperNode of self and a sequence other nodes</pre></div> 
</div>
</div>
<a class="anchor" id="afdd9d57946e0e08e0295199d33b43b12"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lineage" ref="afdd9d57946e0e08e0295199d33b43b12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::lineage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>topNode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return a list of nodes comprising this nodes' lineage (from bottom to top, including this node).
Setting the value of 'topNode' to some existing node allows to stop the lineage construction
at the root of some sub-tree. If some node that is not in the lineage of this node is 
provided as 'topNode', the function will raise an AttributeError when it reaches the root node
and tries to access its parent.</pre></div> 
</div>
</div>
<a class="anchor" id="ab3411b9ab2d887f28283fc2f1b1649ca"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lineageWhile" ref="ab3411b9ab2d887f28283fc2f1b1649ca" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::lineageWhile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return lineage that is cut as soon as an attempt is made to look above the root note or condition(node) returns False.
Can possibly return an empty list.
Condition is always called with a valid node argument.</pre></div> 
</div>
</div>
<a class="anchor" id="a82fdc39394420ab00779563c91a95b5f"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::makePropArrayZeros" ref="a82fdc39394420ab00779563c91a95b5f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::makePropArrayZeros </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return (self.lind,numpy.zeros(number of nodes in subtree)).</pre></div> 
</div>
</div>
<a class="anchor" id="ac114afcdcdf3bad2498a68c7c0234ac3"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::removeChild" ref="ac114afcdcdf3bad2498a68c7c0234ac3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::removeChild </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Remove a child by clearing both parent and child links</pre></div> 
</div>
</div>
<a class="anchor" id="addaf7e7b67013a5450f2b9f2544efc80"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setAttribute" ref="addaf7e7b67013a5450f2b9f2544efc80" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setAttribute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>doCopy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Assign an attribute to every node in a subtree.
@param name Name of attribute
@param value Value, the same for every node
@param doCopy If True, assign copy.copy(value) to every node - 
in case we assigning an empty list that we later want to modify independently for every node</pre></div> 
</div>
</div>
<a class="anchor" id="ad1c29d186f2a22d4573859e2cf2c991e"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setDebugOnUpdate" ref="ad1c29d186f2a22d4573859e2cf2c991e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setDebugOnUpdate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>hook</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Sets new debugging hook to call on attribute update.
@param hook - unbound function with signature f(node,name,value) where
name is attribute name and value is its new value.
@return previous hook function (or None), which can be stored by the caller and
used later to restore the original behavior.</pre></div> 
</div>
</div>
<a class="anchor" id="a8ca6419207107613bc000a9f8a74acec"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setDepth" ref="a8ca6419207107613bc000a9f8a74acec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setDepth </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Recursively set depth for this node and its subtree.</pre></div> 
</div>
</div>
<a class="anchor" id="a2c3a76551fdf1a2d9839227d4fed8d04"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setIndex" ref="a2c3a76551fdf1a2d9839227d4fed8d04" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setIndex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>startIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Index nodes in a subtree in a depth first traversal order.
For each node in a subtree, set attribute lind is the index of the node itself, 
attribute rind is the maximum plus one
index of all nodes in a subtree, including the top node. Index starts at startIndex
and only incremented when node is entered the first time in depth first traversal.
Thus, for any subtree starting at some node, it is easy to create an attribute map as
a dense (Numpy) array: a = numpy.zeros(top.rind - top.lind); a[node.lind-top.lind] = value.
It also makes it easy and fast to work with any subtree below the node:
sub_a = a[sub_top.lind-top.lind:sub_top.rind-top.lind]
sub_a will densely list all values for nodes below the sub_top, with elements accessed as
sub_a[node.lind-sub_top.lind].</pre></div> 
</div>
</div>
<a class="anchor" id="a154bcb893a4deba83c12f16175be1362"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setIsUnderUnclass" ref="a154bcb893a4deba83c12f16175be1362" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setIsUnderUnclass </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Set an attribute 'isUnderUnclass' for the nodes in this branch.
It flags all nodes that have "unclassified" super-node somewhere in their lineage
up to this node including. This node will be marked only if it isUnclassifed().</pre></div> 
</div>
</div>
<a class="anchor" id="a7c632d9896f0fd5cd596e2bd6e0a87e1"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setMaxSubtreeRank" ref="a7c632d9896f0fd5cd596e2bd6e0a87e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setMaxSubtreeRank </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Set an attribute "rank_max" in every node of this subtree that is a highest standard rank of any node in a subtree.
unclassRank and noRank nodes are both considered as noRank in comparisons.
Thus, if and only if all subtree nodes are unclassRank or noRank, "rank_max" is set to noRank.</pre></div> 
</div>
</div>
<a class="anchor" id="a403ecd06e243563770c20f9bac832620"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setParent" ref="a403ecd06e243563770c20f9bac832620" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setParent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>par</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Double-link this node and the parent node.
For speed, we do not check that 'par' is not a parent of this node already,
so this method should not be called twice.</pre></div> 
</div>
</div>
<a class="anchor" id="a6485971ef870f36881ecb3a31c29b3dd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setPropArrayFromAttrib" ref="a6485971ef870f36881ecb3a31c29b3dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setPropArrayFromAttrib </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>base</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Assign values of subtree node attributes to numpy property array.
@param prop - Numpy array
@param name - node attribute name
@param base - indexing will be done as prop[subnode.lind-base]. If 
base is None, the lind of this node will be used.</pre></div> 
</div>
</div>
<a class="anchor" id="ae850d42b40116d7a0c70a0b62b414bc2"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setPropArrayFromFunc" ref="ae850d42b40116d7a0c70a0b62b414bc2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setPropArrayFromFunc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>base</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Assign return value of a func(subnode) to numpy property array.
@param prop - Numpy array
@param func - unary function acting on the subtree node
@param base - indexing will be done as prop[subnode.lind-base]. If 
base is None, the lind of this node will be used.</pre></div> 
</div>
</div>
<a class="anchor" id="ae64d698b01b559f677b713ab52ce1dd4"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setReduction" ref="ae64d698b01b559f677b713ab52ce1dd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setReduction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>dstAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>reduction</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>condition</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>childExtractor</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Assign to 'dstAttr' attribute the result of applying 'reduce(func,...)' to this node and its children.
Example: setTotal() that sums only for non "unclassified" children could be implemented as:
setReduction(srcAttr,dstAttr,operator.add,lambda node: not node.isUnclassified()).
Note: extractor(node) is called unconditionally; condition is only applied to decide whether to extract the value
with childExtractor() from each child sub-node.
Example: collectLeafIds() that assigns to dstAttr a list of all leaf node IDs under each node:
setReduction(lambda node: [ node.id ],dstAttr,operator.add)
Example: same as above, but propagates only a max 'n' elements from a list accumulated for each child node
(can be viewed as a balanced sampling of the tree):
boundedSample = lambda l,n: random.sample(l,min(len(l),n))
setReduction(lambda node: [ node.id ],dstAttr,operator.add,
childExtractor=lambda child: boundedSample(getattr(child,dstAttr),n).
@param extractor - unary function object that is applied to each node to extract the value that is accumulated.
The result is passed as a third argument to 'reduce' built-in.
As a convenient exception, if 'extractor' is a string, it is considered to be a node attribute name.
@param dstAttr - name of destination attribute to set in each node with accumulated result
@param reduction - binary function object that is passed as a first argument to 'reduce' built-in, defaults
to operator.add
@param condition - apply this condition to each child node to decide if it should contribute to the 'dstAttr'
of the parent.
@param childExtractor - unary function object that is applied to each child node of a given node to extract the 
value that is accumulated. The list of results is passed as a second argument to 'reduce' built-in.
As a convenient exception, if 'chilExtractor' is a string, it is considered to be a node attribute name.
Alternatively, if it is None (default), the value of 'dstAttr' of the child node will be extracted.
An example of a non-trivial use of this argument is when we are accumulating a list into 'dstAttr' and want to
extract only a random subset of this list from each child node.
</pre></div> 
</div>
</div>
<a class="anchor" id="a54217795cb97f755da4b347bf1918089"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setTotal" ref="a54217795cb97f755da4b347bf1918089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::setTotal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>srcAttr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>dstAttr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Set total as 'dstAttr' attribute as a sum of 'srcAttr' attribute of this node and all its subnodes.</pre></div> 
</div>
</div>
<a class="anchor" id="a717adeacf7429d92f27bff32192908dd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::unsetDebugOnUpdate" ref="a717adeacf7429d92f27bff32192908dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::unsetDebugOnUpdate </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Remove checks for debugging on attribute update previously set by setDebugOnUpdate().
This removes any run-time penalty for the debugging hook.</pre></div> 
</div>
</div>
<a class="anchor" id="ae13e9b0d297505fbed737a8d39c90f58"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthBottom" ref="ae13e9b0d297505fbed737a8d39c90f58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::visitDepthBottom </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Apply function 'func' to each node traversing the subtree depth-first, applying 'func' after visiting the children.</pre></div> 
</div>
</div>
<a class="anchor" id="a33de4850fa68ac2757abb18eea84cc05"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthTop" ref="a33de4850fa68ac2757abb18eea84cc05" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::visitDepthTop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Apply function 'func' to each node traversing the subtree depth-first, applying 'func' before visiting the children.
If function 'func' returns anything when applied to this node, stop the iteration and return w/o proceeding to the children.</pre></div> 
</div>
</div>
<a class="anchor" id="a85335c13c07a15f9cf18fe7b6d6533c8"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthTwice" ref="a85335c13c07a15f9cf18fe7b6d6533c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::visitDepthTwice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Apply function 'func' to each node twice traversing the subtree depth-first. This is also called modified pre-order traverse.
'func' is applied first time when coming to the node, in which case it is called as func(node,visit=1),
and second time before returning from the node, in which case  it is called as func(node,visit=2).</pre></div> 
</div>
</div>
<a class="anchor" id="af1183314476b765ebdae34a2a9564daa"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::whichSupernode" ref="af1183314476b765ebdae34a2a9564daa" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TaxaTree::TaxaNode::whichSupernode </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>others</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return node from others that is a supernode of self, or None</pre></div> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>mgtaxa/MGT/TaxaTree.py</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 20 2011 17:14:46 for Mgtaxa by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
