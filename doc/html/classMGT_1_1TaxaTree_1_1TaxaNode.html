<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Mgtaxa: MGT::TaxaTree::TaxaNode Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li id="current"><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>MGT</b>::<b>TaxaTree</b>::<a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html">TaxaNode</a></div>
<h1>MGT::TaxaTree::TaxaNode Class Reference</h1><!-- doxytag: class="MGT::TaxaTree::TaxaNode" --><a href="classMGT_1_1TaxaTree_1_1TaxaNode-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#d1c29d186f2a22d4573859e2cf2c991e">setDebugOnUpdate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#717adeacf7429d92f27bff32192908dd">unsetDebugOnUpdate</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#0fd2e60fa74f1293c8f37c0a57f398a1">__getstate__</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#c48fbe561552754675f5c34ed23aac23">_debugSetAttr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#403ecd06e243563770c20f9bac832620">setParent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#fdd9d57946e0e08e0295199d33b43b12">lineage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#b3411b9ab2d887f28283fc2f1b1649ca">lineageWhile</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#2d6b844eaa8e9144371b217422029010">findLeftRankInLineage</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#33de4850fa68ac2757abb18eea84cc05">visitDepthTop</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#8799aea055e40ba8fdcb44fa36dff694">iterDepthTop</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#b09fc1ddd5aeb22e6796888079b63c55">iterDepthTwice</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#b70ca116c742c9a2cff520c7b652b6cc">iterFillUp</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#e13e9b0d297505fbed737a8d39c90f58">visitDepthBottom</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#85335c13c07a15f9cf18fe7b6d6533c8">visitDepthTwice</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#75e81088485134696e4a9896a88ca816">getDepth</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#8ca6419207107613bc000a9f8a74acec">setDepth</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#2c3a76551fdf1a2d9839227d4fed8d04">setIndex</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#82fdc39394420ab00779563c91a95b5f">makePropArrayZeros</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#6485971ef870f36881ecb3a31c29b3dd">setPropArrayFromAttrib</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#e850d42b40116d7a0c70a0b62b414bc2">setPropArrayFromFunc</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#54217795cb97f755da4b347bf1918089">setTotal</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#e64d698b01b559f677b713ab52ce1dd4">setReduction</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#7c632d9896f0fd5cd596e2bd6e0a87e1">setMaxSubtreeRank</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#ddaf7e7b67013a5450f2b9f2544efc80">setAttribute</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#a982357b4bd2d7715598054d759e6df8">isSubnode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#6d3895e33537f43dc44b55b8edf389bd">isUnder</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#f1183314476b765ebdae34a2a9564daa">whichSupernode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#d4eda6b3eeec312541beb372e02d6c86">lcsNode</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#4d86f42266a6e38d20ce1ca6c1d9b851">lcsNodeMany</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">def&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TaxaTree_1_1TaxaNode.html#154bcb893a4deba83c12f16175be1362">setIsUnderUnclass</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment">Node of a taxonomy tree.</pre></div> 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="0fd2e60fa74f1293c8f37c0a57f398a1"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::__getstate__" ref="0fd2e60fa74f1293c8f37c0a57f398a1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::__getstate__           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Pickling support - exclude node cross references to improve memory and performance 100x.
The TaxaTree constructor can restore the internal tree structure from remaining data.
The TaxaTreeIO.NodeStoragePickle relies on this.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="c48fbe561552754675f5c34ed23aac23"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::_debugSetAttr" ref="c48fbe561552754675f5c34ed23aac23" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::_debugSetAttr           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">This method will replace the default __setattr__ and call the debugging hook.
This is set by by @see setDebugOnUpdate().</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="2d6b844eaa8e9144371b217422029010"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::findLeftRankInLineage" ref="2d6b844eaa8e9144371b217422029010" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::findLeftRankInLineage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>ranks</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>topNode</em> = <code>None</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return a node corresponding to the left-most element from 'ranks' found in the lineage</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="75e81088485134696e4a9896a88ca816"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::getDepth" ref="75e81088485134696e4a9896a88ca816" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::getDepth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return distance to the top of the tree.
Depth must be precalculated for each node by a call to TaxaTree.setDepth().</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="a982357b4bd2d7715598054d759e6df8"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::isSubnode" ref="a982357b4bd2d7715598054d759e6df8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::isSubnode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>other</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return true if this node is a descendant of the other node.
Uses pre-computed nested sets indexes, which must be up-to-date.
@note A node is not considered a subnode of itself - see isUnder() for this.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="6d3895e33537f43dc44b55b8edf389bd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::isUnder" ref="6d3895e33537f43dc44b55b8edf389bd" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::isUnder           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>other</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>withSelf</em> = <code>False</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return true if this node is a descendant of the other node or the other node itself.
Uses pre-computed nested sets indexes, which must be up-to-date.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="8799aea055e40ba8fdcb44fa36dff694"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterDepthTop" ref="8799aea055e40ba8fdcb44fa36dff694" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::iterDepthTop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return depth-first top-to-bottom iterator.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="b09fc1ddd5aeb22e6796888079b63c55"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterDepthTwice" ref="b09fc1ddd5aeb22e6796888079b63c55" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::iterDepthTwice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return depth-first on-entry+on-exit iterator (modified preorder).
Dereferencing the iterator yields (node,visit) tuple, where visit is either 1 or 2 according to the time that we visit this node.
See setNestedSetsIndex() method for application example.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="b70ca116c742c9a2cff520c7b652b6cc"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::iterFillUp" ref="b70ca116c742c9a2cff520c7b652b6cc" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::iterFillUp           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>topNode</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>topFirst</em> = <code>False</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Iterate as though we were pouring water into this node until it fills a given super-tree above it.
@param topNode - "fill up" up to this super-node (inclusive), None means up to root node.
@param topFirst - if True, the top node of each super-tree will be iterated before its sub-nodes, otherwise - after ("self" is always iterated first).</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="d4eda6b3eeec312541beb372e02d6c86"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lcsNode" ref="d4eda6b3eeec312541beb372e02d6c86" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::lcsNode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>other</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return the Lowest Common SuperNode of self and other</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="4d86f42266a6e38d20ce1ca6c1d9b851"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lcsNodeMany" ref="4d86f42266a6e38d20ce1ca6c1d9b851" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::lcsNodeMany           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>others</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return the Lowest Common SuperNode of self and a sequence other nodes</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="fdd9d57946e0e08e0295199d33b43b12"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lineage" ref="fdd9d57946e0e08e0295199d33b43b12" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::lineage           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>topNode</em> = <code>None</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return a list of nodes comprising this nodes' lineage (from bottom to top, including this node).
Setting the value of 'topNode' to some existing node allows to stop the lineage construction
at the root of some sub-tree. If some node that is not in the lineage of this node is 
provided as 'topNode', the function will raise an AttributeError when it reaches the root node
and tries to access its parent.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="b3411b9ab2d887f28283fc2f1b1649ca"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::lineageWhile" ref="b3411b9ab2d887f28283fc2f1b1649ca" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::lineageWhile           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return lineage that is cut as soon as an attempt is made to look above the root note or condition(node) returns False.
Can possibly return an empty list.
Condition is always called with a valid node argument.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="82fdc39394420ab00779563c91a95b5f"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::makePropArrayZeros" ref="82fdc39394420ab00779563c91a95b5f" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::makePropArrayZeros           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>dtype</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return (self.lind,numpy.zeros(number of nodes in subtree)).</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="ddaf7e7b67013a5450f2b9f2544efc80"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setAttribute" ref="ddaf7e7b67013a5450f2b9f2544efc80" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setAttribute           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>doCopy</em> = <code>False</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Assign an attribute to every node in a subtree.
@param name Name of attribute
@param value Value, the same for every node
@param doCopy If True, assign copy.copy(value) to every node - 
in case we assigning an empty list that we later want to modify independently for every node</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="d1c29d186f2a22d4573859e2cf2c991e"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setDebugOnUpdate" ref="d1c29d186f2a22d4573859e2cf2c991e" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setDebugOnUpdate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>hook</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Sets new debugging hook to call on attribute update.
@param hook - unbound function with signature f(node,name,value) where
name is attribute name and value is its new value.
@return previous hook function (or None), which can be stored by the caller and
used later to restore the original behavior.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="8ca6419207107613bc000a9f8a74acec"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setDepth" ref="8ca6419207107613bc000a9f8a74acec" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setDepth           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>depth</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Recursively set depth for this node and its subtree.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="2c3a76551fdf1a2d9839227d4fed8d04"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setIndex" ref="2c3a76551fdf1a2d9839227d4fed8d04" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setIndex           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>startIndex</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Index nodes in a subtree in a depth first traversal order.
For each node in a subtree, set attribute lind is the index of the node itself, 
attribute rind is the maximum plus one
index of all nodes in a subtree, including the top node. Index starts at startIndex
and only incremented when node is entered the first time in depth first traversal.
Thus, for any subtree starting at some node, it is easy to create an attribute map as
a dense (Numpy) array: a = numpy.zeros(top.rind - top.lind); a[node.lind-top.lind] = value.
It also makes it easy and fast to work with any subtree below the node:
sub_a = a[sub_top.lind-top.lind:sub_top.rind-top.lind]
sub_a will densely list all values for nodes below the sub_top, with elements accessed as
sub_a[node.lind-sub_top.lind].</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="154bcb893a4deba83c12f16175be1362"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setIsUnderUnclass" ref="154bcb893a4deba83c12f16175be1362" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setIsUnderUnclass           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Set an attribute 'isUnderUnclass' for the nodes in this branch.
It flags all nodes that have "unclassified" super-node somewhere in their lineage
up to this node including. This node will be marked only if it isUnclassifed().</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="7c632d9896f0fd5cd596e2bd6e0a87e1"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setMaxSubtreeRank" ref="7c632d9896f0fd5cd596e2bd6e0a87e1" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setMaxSubtreeRank           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>self</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Set an attribute "rank_max" in every node of this subtree that is a highest standard rank of any node in a subtree.
unclassRank and noRank nodes are both considered as noRank in comparisons.
Thus, if and only if all subtree nodes are unclassRank or noRank, "rank_max" is set to noRank.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="403ecd06e243563770c20f9bac832620"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setParent" ref="403ecd06e243563770c20f9bac832620" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setParent           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>par</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Double-link this node and the parent node.
For speed, we do not check that 'par' is not a parent of this node already,
so this method should not be called twice.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="6485971ef870f36881ecb3a31c29b3dd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setPropArrayFromAttrib" ref="6485971ef870f36881ecb3a31c29b3dd" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setPropArrayFromAttrib           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>prop</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>base</em> = <code>None</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Assign values of subtree node attributes to numpy property array.
@param prop - Numpy array
@param name - node attribute name
@param base - indexing will be done as prop[subnode.lind-base]. If 
base is None, the lind of this node will be used.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="e850d42b40116d7a0c70a0b62b414bc2"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setPropArrayFromFunc" ref="e850d42b40116d7a0c70a0b62b414bc2" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setPropArrayFromFunc           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>prop</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>base</em> = <code>None</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Assign return value of a func(subnode) to numpy property array.
@param prop - Numpy array
@param func - unary function acting on the subtree node
@param base - indexing will be done as prop[subnode.lind-base]. If 
base is None, the lind of this node will be used.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="e64d698b01b559f677b713ab52ce1dd4"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setReduction" ref="e64d698b01b559f677b713ab52ce1dd4" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setReduction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>extractor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>dstAttr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>reduction</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>condition</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>childExtractor</em> = <code>None</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Assign to 'dstAttr' attribute the result of applying 'reduce(func,...)' to this node and its children.
Example: setTotal() that sums only for non "unclassified" children could be implemented as:
setReduction(srcAttr,dstAttr,operator.add,lambda node: not node.isUnclassified()).
Note: extractor(node) is called unconditionally; condition is only applied to decide whether to extract the value
with childExtractor() from each child sub-node.
Example: collectLeafIds() that assigns to dstAttr a list of all leaf node IDs under each node:
setReduction(lambda node: [ node.id ],dstAttr,operator.add)
Example: same as above, but propagates only a max 'n' elements from a list accumulated for each child node
(can be viewed as a balanced sampling of the tree):
boundedSample = lambda l,n: random.sample(l,min(len(l),n))
setReduction(lambda node: [ node.id ],dstAttr,operator.add,
childExtractor=lambda child: boundedSample(getattr(child,dstAttr),n).
@param extractor - unary function object that is applied to each node to extract the value that is accumulated.
The result is passed as a third argument to 'reduce' built-in.
As a convenient exception, if 'extractor' is a string, it is considered to be a node attribute name.
@param dstAttr - name of destination attribute to set in each node with accumulated result
@param reduction - binary function object that is passed as a first argument to 'reduce' built-in, defaults
to operator.add
@param condition - apply this condition to each child node to decide if it should contribute to the 'dstAttr'
of the parent.
@param childExtractor - unary function object that is applied to each child node of a given node to extract the 
value that is accumulated. The list of results is passed as a second argument to 'reduce' built-in.
As a convenient exception, if 'chilExtractor' is a string, it is considered to be a node attribute name.
Alternatively, if it is None (default), the value of 'dstAttr' of the child node will be extracted.
An example of a non-trivial use of this argument is when we are accumulating a list into 'dstAttr' and want to
extract only a random subset of this list from each child node.
</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="54217795cb97f755da4b347bf1918089"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::setTotal" ref="54217795cb97f755da4b347bf1918089" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::setTotal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>srcAttr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>dstAttr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Set total as 'dstAttr' attribute as a sum of 'srcAttr' attribute of this node and all its subnodes.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="717adeacf7429d92f27bff32192908dd"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::unsetDebugOnUpdate" ref="717adeacf7429d92f27bff32192908dd" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::unsetDebugOnUpdate           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Remove checks for debugging on attribute update previously set by setDebugOnUpdate().
This removes any run-time penalty for the debugging hook.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="e13e9b0d297505fbed737a8d39c90f58"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthBottom" ref="e13e9b0d297505fbed737a8d39c90f58" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::visitDepthBottom           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Apply function 'func' to each node traversing the subtree depth-first, applying 'func' after visiting the children.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="33de4850fa68ac2757abb18eea84cc05"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthTop" ref="33de4850fa68ac2757abb18eea84cc05" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::visitDepthTop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Apply function 'func' to each node traversing the subtree depth-first, applying 'func' before visiting the children.
If function 'func' returns anything when applied to this node, stop the iteration and return w/o proceeding to the children.</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="85335c13c07a15f9cf18fe7b6d6533c8"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::visitDepthTwice" ref="85335c13c07a15f9cf18fe7b6d6533c8" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::visitDepthTwice           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>func</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Apply function 'func' to each node twice traversing the subtree depth-first. This is also called modified pre-order traverse.
'func' is applied first time when coming to the node, in which case it is called as func(node,visit=1),
and second time before returning from the node, in which case  it is called as func(node,visit=2).</pre></div>     </td>
  </tr>
</table>
<a class="anchor" name="f1183314476b765ebdae34a2a9564daa"></a><!-- doxytag: member="MGT::TaxaTree::TaxaNode::whichSupernode" ref="f1183314476b765ebdae34a2a9564daa" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">def MGT::TaxaTree::TaxaNode::whichSupernode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">&nbsp;</td>
          <td class="mdname" nowrap> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>others</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<div class="fragment"><pre class="fragment">Return node from others that is a supernode of self, or None</pre></div>     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>mgtaxa/MGT/TaxaTree.py</ul>
<hr size="1"><address style="align: right;"><small>Generated on Sat May 8 15:32:21 2010 for Mgtaxa by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
