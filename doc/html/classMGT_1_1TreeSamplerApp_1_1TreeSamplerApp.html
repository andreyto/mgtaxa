<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mgtaxa: MGT::TreeSamplerApp::TreeSamplerApp Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>MGT</b>      </li>
      <li><b>TreeSamplerApp</b>      </li>
      <li><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html">TreeSamplerApp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>MGT::TreeSamplerApp::TreeSamplerApp Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="MGT::TreeSamplerApp::TreeSamplerApp" --><!-- doxytag: inherits="MGT::Config::MGTOptions,MGT::App::App" --><!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for MGT::TreeSamplerApp::TreeSamplerApp:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.png" usemap="#MGT::TreeSamplerApp::TreeSamplerApp_map" alt=""/>
  <map id="MGT::TreeSamplerApp::TreeSamplerApp_map" name="MGT::TreeSamplerApp::TreeSamplerApp_map">
<area href="classMGT_1_1App_1_1App.html" alt="MGT::App::App" shape="rect" coords="0,0,241,24"/>
</map>
 </div><!-- endSectionContent --></div>

<p><a href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a5b87e6b93f06b766ecb3b69c8321c38f">__init__</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a0ae93119a576428816058eecf38eef99">initWork</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ac588e0fcdc5a9d1b22154a8f35c782c4">getTableName</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ad4f8262b0ce121334095cc4b7f46a0cd">getFilePath</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a4a1ecd97aacb6af65170b480df2ce3a4">doWork</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a8f75875ddaf1064a2489c44372e4f83c">mkDbSampleCounts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a6a9e77ab6b21d5715f55116e24fd8b10">loadSampleCountsMem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ae556261d17aaea7f85f3ece1e5fead31">setIsUnderUnclassMem</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a52b3f765fe853bfbef168f58fd6e82b3">markTrainable</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ac136299579252c2963a8538cab247491">unused_mkDbTestingTaxa</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a16a05eafe8d7d7198f5d257790d38f49">unused_lowRankTestPairs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ae38d8d606cf2d1d8d350cf621150edde">unused_sampleTestPairs</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a96894d8a1c0ba001c7eef7138c09a090">isTestTerm</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a7667e4d3ace81327f21e38677561fa89">selectTestTaxa</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ad2b68e3bae905e7a57aaea4b074b2c3a">markTraining</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a68f818e4663b8617d9883e3166909479">checkPostMarkTraining</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a06f92038152e25101fe929b8e52368df">statTestTaxa</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a0356aa918e89b278d4597d691397bcf9">writeTraining</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a3f52ffe9992bd8cdfbf638af3bb7eb00">pickRandomSampleCounts</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a0c1ad7fe84e6dee1345d78db4e13a4f9">writeTesting</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aec4359af608cb0b048cefca780d3c06a"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::idLabRecs" ref="aec4359af608cb0b048cefca780d3c06a" args="" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#aec4359af608cb0b048cefca780d3c06a">idLabRecs</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to allocate enough idLab records for both training and testing, but wrap it in ArrayAppender just in case we reach the end at some point. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7cd5ff20b7fc98ae10c0e021f5cb048f"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::labToName" ref="a7cd5ff20b7fc98ae10c0e021f5cb048f" args="" -->
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a7cd5ff20b7fc98ae10c0e021f5cb048f">labToName</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">labToName items that are always present, others will be added later - "rj" reject group, always 0; "bg" background samples, always 1 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ad4216b291efeef551e2a6d7f26226f12">sampNTrainSelf</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a09f78fce7160bc74f360d3cfa60b36"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::termTopRankSeq" ref="a9a09f78fce7160bc74f360d3cfa60b36" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#a9a09f78fce7160bc74f360d3cfa60b36">termTopRankSeq</a> = &quot;_sequence&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constant to control splitting - will cause splitting along nodes with directly attached sequence. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abfa5e13cf41d156501faa942172d3609"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::termTopRankLeaf" ref="abfa5e13cf41d156501faa942172d3609" args="" -->
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#abfa5e13cf41d156501faa942172d3609">termTopRankLeaf</a> = &quot;_leaf&quot;</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Special constant to control splitting - will cause splitting along leaf nodes. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="fragment"><pre class="fragment">Sample chunks of available training sequence by concatenating all sequences for each taxid.
Concatenating (as opposed to chunking each sequence individually) greatly simplifies random
sampling of taxid chunks w/o replacement and increases the amount of sample data for small
sequences. It creates chimeric k-mer vectors however (but not chimeric k-mers because we insert
spacers).</pre></div> <hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5b87e6b93f06b766ecb3b69c8321c38f"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::__init__" ref="a5b87e6b93f06b766ecb3b69c8321c38f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Constructor.
@param args optional command line arguments to parse -
if executing as a module, should pass None or sys.argv[1:], else - [], which should result in 
default values generated for all options not defined by opt.
@param opt Struct instance - values defined here will override those parsed from args.
Two basic use patterns: 
if running as a shell script and parsing actual command line arguments:
    app = App(args=None)
    app.run()
if calling from Python code:
    construct opt as a Struct() instance, specify only attributes with non-default values, then
    app = App(opt=opt) #that fills yet unset options with defaults
    app.run() #either runs in the same process, or submits itself or a set of other Apps to batch queue
</pre></div> 
<p>Reimplemented from <a class="el" href="classMGT_1_1App_1_1App.html#a6afec083a426fe4cc388fe50c0e738ab">MGT::App::App</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a68f818e4663b8617d9883e3166909479"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::checkPostMarkTraining" ref="a68f818e4663b8617d9883e3166909479" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::checkPostMarkTraining </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Consistency check after a call to markTraining().</pre></div> 
</div>
</div>
<a class="anchor" id="a4a1ecd97aacb6af65170b480df2ce3a4"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::doWork" ref="a4a1ecd97aacb6af65170b480df2ce3a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::doWork </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Do the actual work.
Must be redefined in the derived classes.
Should not be called directly by the user except from doWork() in a derived class.
Should work with empty keyword dict, using only self.opt.
If doing batch submision of other App instances, must return a list of sink (final) BatchJob objects.</pre></div> 
<p>Reimplemented from <a class="el" href="classMGT_1_1App_1_1App.html#a7dbfd4f4b688baa8b586ac92f0a1b368">MGT::App::App</a>.</p>

</div>
</div>
<a class="anchor" id="ad4f8262b0ce121334095cc4b7f46a0cd"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::getFilePath" ref="ad4f8262b0ce121334095cc4b7f46a0cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::getFilePath </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Same as getTableName() but for files.</pre></div> 
</div>
</div>
<a class="anchor" id="ac588e0fcdc5a9d1b22154a8f35c782c4"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::getTableName" ref="ac588e0fcdc5a9d1b22154a8f35c782c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::getTableName </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Given a stem table name, return full table name unique for this object (prefix+name).
@param name - stem name
</pre></div> 
</div>
</div>
<a class="anchor" id="a0ae93119a576428816058eecf38eef99"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::initWork" ref="a0ae93119a576428816058eecf38eef99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::initWork </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Perform common initialization right before doing the actual work in doWork().
Must be redefined in the derived classes.
Should not be called directly by the user except from initWork() in a derived class.
This one can create large objects because they are not passed through the batch submission,
but immediately used within the same process.</pre></div> 
<p>Reimplemented from <a class="el" href="classMGT_1_1App_1_1App.html#a50b6fb63d2c7f4e18770f2e27405ac54">MGT::App::App</a>.</p>

</div>
</div>
<a class="anchor" id="a96894d8a1c0ba001c7eef7138c09a090"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::isTestTerm" ref="a96894d8a1c0ba001c7eef7138c09a090" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::isTestTerm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return True if the node is designated as testing terminal.
If True, the node and its subtree can be used only in its entirety either for training or for testing split.
Currently the implementation of this methods checks if node's rank is present in self.opt.termTopRanks,
with the two special names allowed in self.opt.termTopRanks: 
1) when termTopRanks list contains element equal to self.termTopRankSeq constant, we return True for
every node that has directly attached sequence.
2) when termTopRanks list contains element equal to self.termTopRankLeaf constant, we return True for
every leaf node (without children).
The typical use to have either actual ranks in self.opt.termTopRanks, or either one of the special
constants.
Redefine this method in derived classes to use some more complicated splitting criterion.
For the default implementation, if for example, we return True for species nodes, then sequences under 
species will be never split between training and testing. That ensures proper validation of a claim 
that testing accuracy is provided for the dicovery of previously unseen species.
@note PhyloPythia 2006 paper used splits as the level of strains (or whatever the leaf sequence
taxonomy node was for).
@attention It is often the case that a species node will have directly attached sequence, while
also having strains under it with their own sequence. Most of the time, the species level sequence
is not genome-wide sequencing output, but rather sequences for some specific genes. There examples
when it is a full plasmid sequence, e.g. Aeromonas salmonicida taxid 645.
If we ignore in sample database construction everything but WGS and full genomes, and drop plasmids,
we are probably safe.
However, dealing with it in a general case probably makes sense if just pick leaf nodes as testing
terminal and ignore any sequence attached to their upper nodes.</pre></div> 
</div>
</div>
<a class="anchor" id="a6a9e77ab6b21d5715f55116e24fd8b10"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::loadSampleCountsMem" ref="a6a9e77ab6b21d5715f55116e24fd8b10" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::loadSampleCountsMem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Transfer sample counts from DB into in-memory taxonomy tree object.</pre></div> 
</div>
</div>
<a class="anchor" id="a52b3f765fe853bfbef168f58fd6e82b3"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::markTrainable" ref="a52b3f765fe853bfbef168f58fd6e82b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::markTrainable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Mark all nodes that have enough samples for training with and without validation.
When we train for subsequent validation with testing set, we cannot use any 'unclassified'
samples because they might actually represent the excluded testing set. On the other
hand, there is no reason not to use any 'unclassified' samples under a 'classified'
node for the final re-training.
@pre loadSampleCountsMem() and setInUnderUnclassMem() were called
@post in-memory taxaTree nodes have the following attributes set:
    isTrainable - trainable with 'unclassifed' samples included
    isTrainableTest - trainable for validation. A node can still be excluded from
    testing later if extracting testing set will leave too few samples for training,
    but it will be trained during testing stage - just will not have any true positive 
    testing samples.</pre></div> 
</div>
</div>
<a class="anchor" id="ad2b68e3bae905e7a57aaea4b074b2c3a"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::markTraining" ref="ad2b68e3bae905e7a57aaea4b074b2c3a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::markTraining </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Mark final training state for each node - 'is_class' and 'n_mclass' attributes.
Nodes that are not 'is_class' are ignored during training.
'is_class' means that a node can be used as a label in training the
multiclass classifier for the parent node.
'n_mclass' is also set to the number of classes below the node.
'samp_n_max' is the maximum leaf sample count under this node.
This method must be called after selectTestTaxa() and uses node attributes set by
that method.</pre></div> 
</div>
</div>
<a class="anchor" id="a8f75875ddaf1064a2489c44372e4f83c"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::mkDbSampleCounts" ref="a8f75875ddaf1064a2489c44372e4f83c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::mkDbSampleCounts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Make DB tables with sample counts per taxonomy id</pre></div> 
</div>
</div>
<a class="anchor" id="a3f52ffe9992bd8cdfbf638af3bb7eb00"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::pickRandomSampleCounts" ref="a3f52ffe9992bd8cdfbf638af3bb7eb00" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::pickRandomSampleCounts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Randomly pick counts of available samples from taxonomy ids below the node.
@return dictionary { taxid -&gt; count }.
Should be called from writeTraining() which sets up sampNTrainTot and sampNTrainSelf
node property arrays.</pre></div> 
</div>
</div>
<a class="anchor" id="a7667e4d3ace81327f21e38677561fa89"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::selectTestTaxa" ref="a7667e4d3ace81327f21e38677561fa89" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::selectTestTaxa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Select nodes that will be used entirely for testing.
The method aims to achieve these goals:
- create a uniform random sampling of the tree
- sample as deep into the hierarchy as possible
- select entire genera or entire species if there is no genera above them
(we call such nodes "terminal" here)
This is done recursively: for a given node: 
a) all taxa selected as testing for its non-terminal children is also selected
b) and then terminal children are added at random until we reach the limit on 
testing samples set for this node.
The major alternative would be to do the (b) selection from a list of all
so far non-selected terminal subnodes in an entire sub-tree of a given node
(the method would have to return such a list from each recursive call, with the
parent concatenating the lists). This would provided better chances to reach the
testing ratio target for higher order taxa. However, this would also run a danger
of a non-uniform training and deteriorating perfomance. For example, if we have
a subtree (A,(B,C),D) and B was selected as testing for (B,C) subtree, we could also
select C as testing for (A,(B,C),D) subtree (it would still be used as training
for (B,C). However, we would have no trainig samples from (B,C) when trainig (A,(B,C),D),
which can become an issue.
@post Attributes are set for each node:
    - is_test - if True, entire subtree is selected as testing sample. Set for every node
    in such a subtree.
    - has_test - if True, node has enough testing samples, but it is not 'is_test' itself.
    - samp_n_tot_test - number of testing samples for this node
    - samp_n_tot_train - number of training samples for this node.
    - isTestTerm - split boundaries (entire subtrees can have either True or False)
Note that the presence of "unclassified" sequence still creates problems:
selection of even one testing sample excludes from training all unclassified nodes
which are immediate children of all nodes in testing sample lineage. Thus, any of these nodes
can become non-trainable even if it is trainable w/o testing. However, we need to accumulate
the testing sequence for use by upper nodes, so this seems unavoidable. To check the effect
of this tradeoff, temporarily make TaxaNode.isUnclassified() to always return False and re-run
the testing/training selection. So far this experiment shown little impact.</pre></div> 
</div>
</div>
<a class="anchor" id="ae556261d17aaea7f85f3ece1e5fead31"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::setIsUnderUnclassMem" ref="ae556261d17aaea7f85f3ece1e5fead31" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::setIsUnderUnclassMem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Set an attribute 'isUnderUnclass' for in-memory tree nodes.
It flags all nodes that have "unclassified" super-node somewhere in their lineage.</pre></div> 
</div>
</div>
<a class="anchor" id="a06f92038152e25101fe929b8e52368df"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::statTestTaxa" ref="a06f92038152e25101fe929b8e52368df" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::statTestTaxa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>&#160;)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Save SQL statistics about testing/training set selection.
Call after markTraining()</pre></div> 
</div>
</div>
<a class="anchor" id="a16a05eafe8d7d7198f5d257790d38f49"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::unused_lowRankTestPairs" ref="a16a05eafe8d7d7198f5d257790d38f49" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::unused_lowRankTestPairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>superRank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Return set of unique pairs (testing node,first supernode).
@param rank - entire nodes of this rank will be selected as testing samples (e.g. genus).
@param superRank - a second member of each pair will have at least this rank (e.g. family).
'superRank' nodes might not be 'isTrainable'. That should be filtered later.</pre></div> 
</div>
</div>
<a class="anchor" id="ac136299579252c2963a8538cab247491"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::unused_mkDbTestingTaxa" ref="ac136299579252c2963a8538cab247491" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::unused_mkDbTestingTaxa </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>rank</em> = <code>&quot;genus&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>superRank</em> = <code>&quot;family&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Select complete 'rank' nodes uniformly distributed across 'superRank' super-nodes.</pre></div> 
</div>
</div>
<a class="anchor" id="ae38d8d606cf2d1d8d350cf621150edde"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::unused_sampleTestPairs" ref="ae38d8d606cf2d1d8d350cf621150edde" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::unused_sampleTestPairs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Randomly sample a list of (testing node,first supernode) pairs obtained with lowRankTestPairs().</pre></div> 
</div>
</div>
<a class="anchor" id="a0c1ad7fe84e6dee1345d78db4e13a4f9"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::writeTesting" ref="a0c1ad7fe84e6dee1345d78db4e13a4f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::writeTesting </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>svmWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Write testing data set.
@pre Nodes have the following attributes: 
is_class - True for nodes that can serve as classes in SVM
n_mclass - number of trainable sub-classes
samp_n_tot_test - number of testing samples in a subtree
is_test - True if a subtree is used for testing
This method must be called after markTraining() sets needed node attributes.
</pre></div> 
</div>
</div>
<a class="anchor" id="a0356aa918e89b278d4597d691397bcf9"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::writeTraining" ref="a0356aa918e89b278d4597d691397bcf9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def MGT::TreeSamplerApp::TreeSamplerApp::writeTraining </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>trNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"> <em>svmWriter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">Write training data set for each eligible node.
@pre Nodes have the following attributes: 
is_class - True for nodes that can serve as classes in SVM
n_mclass - number of trainable sub-classes
samp_n_tot_test - number of testing samples in a subtree
samp_n_tot_train - number of training samples in a subtree (excluding testing)
is_test - True if a subtree is used for testing
@post Data sets ready for feature generation are saved.
@post taxaTree.getRootNode().setIndex() resets internal node index.
This method must be called after markTraining() sets needed node attributes.
</pre></div> 
</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ad4216b291efeef551e2a6d7f26226f12"></a><!-- doxytag: member="MGT::TreeSamplerApp::TreeSamplerApp::sampNTrainSelf" ref="ad4216b291efeef551e2a6d7f26226f12" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMGT_1_1TreeSamplerApp_1_1TreeSamplerApp.html#ad4216b291efeef551e2a6d7f26226f12">MGT::TreeSamplerApp::TreeSamplerApp::sampNTrainSelf</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>make conditional on not is_test </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>mgtaxa/MGT/TreeSamplerApp.py</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jan 20 2011 17:14:47 for Mgtaxa by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
